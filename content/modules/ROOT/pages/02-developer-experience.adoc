
= Developer Experience with Dev Spaces

* Imagine you are a new developer joining a project called *GuestBook*. 
* Thanks to *OpenShift Dev Spaces*, your onboarding process will be quick, seamless, and fully automated. 
* Here’s how your journey 
. Your manager provides you with a link to access *OpenShift Dev Spaces* directly from your browser.
. The moment you click the link, the **Dev Spaces Gateway** authenticates your credentials and directs your request to the *Dev Spaces Server*. 
. The *Dev Spaces Server* processes the request and sends the necessary information back to your browser, displaying the *Dev Spaces Dashboard*.
. On the *Dev Spaces Dashboard*, you’ll find the *GuestBook*project. Simply clicking on it initiates the next step, the *Dev Spaces Server* reads the *devfile* for the project.
. The *devfile* contains all the essential information you need to start developing—runtimes, dependencies, and development tools. Everything is pre-configured for you.
. Once the *Dev Spaces Server* reads the *devfile*, it creates a dedicated Project in OpenShift just for you, and spins up a *workspace* configured exactly as specified in the *devfile*.
. This entire process ensures that you have a fully tailored development environment without needing to set up anything manually. You’re ready to code from the moment you access the project.

image::developer_onboarding.png[]

* Now it’s time to try this out hands-on. In this module, you’ll experience firsthand how *OpenShift Dev Spaces* simplifies your onboarding and development process.

---

== Lab 2.1 Developer Onboarding 

=== Lab 2.1.1: Login to OpenShift Dev Spaces

* Open the *Red Hat Applications* menu by using the *three-by-three matrix* icon in the upper right corner of the main screen.
* Click the *OpenShift Dev Spaces* link to open the *Dev Spaces Dashboard*.


image::three_by_three_matrix.png[]

---

* You will be prompted to log in using your *OpenShift* credentials. Please use the following:
** username: user1
** password: openshift

image::login_with_openshift.png[]

---

* On the *Authorize Access* screen, click the *Allow Select Permissions* button to grant the necessary permissions.

image::authorize_access.png[]

---

* Once authenticated, you will be greeted by the **OpenShift Dev Spaces dashboard**, your central hub for managing workspaces and projects.

image::dev_spaces_dashboard.png[]

---

=== Lab 2.1.2: Create your first workspace

* Let’s create a workspace for the *GuestBook* project.
* Paste the following link to the GitHub repository into the field **Git Repo URL** within the dashboard to import the project.
** https://github.com/relessawy/devspaces_guestbook/
* Click the **Create & Open** button

image::import_from_git.png[]

---

* It will take the *Dev Spaces server* a few minutes to process the *devfile* and spin up your *workspace*.

image::starting_workspace.png[]

---

* A pop-up will appear, asking, “Do you trust the authors of the files in this folder?” This is a standard security measure to ensure that the files you are about to use are safe and come from a reliable source.
* Click the **Yes, I trust the authors** button.

image::trust_authors.png[]

---

=== Lab 2.1.3: Explore workspace pods

* Now that your *workspace* is set up, let’s switch back to the *OpenShift* console to see what happened behind the scenes during this process.
* In the top left corner of the OpenShift console, click the *Project dropdown list* to view all projects.
* You will notice a new project called *user1-devspaces*.has been automatically created for you. 
* This project was automatically created by *OpenShift Dev Spaces* as your personal development environment based on the *devfile* configuration.

image::project_list.png[]

* Select **user1-devspaces** to switch to this project.

---

* Let’s take a closer look at the pod hosting your *workspace* within the *user1-devspaces* project. 

image::workspace_pod.png[]

* To gain deeper insights into the pod’s details, switch to the *Administrator* perspective in your OpenShift console.
* In the *Administrator* view, go to *Workloads* and select Pods. 
* You’ll see that the pod associated with your *workspace* has two running containers.

image::pods_view.png[]

* Click on the pod associated with your workspace to drill a bit deeper. The two running containers are:
• *nodejs*: This container provides the Node.js runtime, which is essential for running your *GuestBook* application.
• **che-gateway**: This container is responsible for managing the gateway operations that route traffic and commands within your workspace.

image::workspace_containers.png[]

---

=== Lab 2.1.4: Examine the Guestbook devfile

* Let’s return to your *VSCode* tab in the browser to take a closer look at the *devfile* used for our *GuestBook* project. 
* This devfile serves as the blueprint for setting up the development environment.

image::guestbook_devfile.png[]

==== 1 Components
* We start by listing our components, In this case, the *devfile* defines a Node.js container that provides the runtime for the *GuestBook* application.


==== 2 Universal Developer Image (UDI)
* We are are using the *Universal Developer Image (UDI)* to create this container.
* The *UDI* is a versatile image that includes all the essential runtimes and tools developers need to code efficiently, making it an ideal choice for development environments.

==== 3 Volume

* Next, we define a volume named NPM to store our dependencies.
* This volume ensures that our dependencies are preserved across container restarts and development sessions.

==== 4 Commands

* Lastly, we define the commands that can be executed within the *workspace*. 
* In the case of the *GuestBook* project, we have commands to build and run the application, allowing us to easily execute project-related tasks from within the workspace.

---

=== Lab 2.1.5: Test the run command

* Let’s go ahead and execute the *Run the application* defined in the *devfile*.
* You’ll notice that the *Task Manager* extension is already pre-installed in your workspace.

image:task_manager_ext.png[]

* Any extensions defined in the ’extensions.json’ file located under the ’.vscode’ folder will automatically be pre-installed in your *workspace*. 
* This ensures a standardized development environment for all developers working on the *GuestBook* project.

image:extensions_file.png[]

* The *Task Manager* extension simplifies running the commands defined in our *devfile*.
* To run the application, select and run the command *Run the application command* under the *devfile* section in *Task Manager*.

image::run_command.png[]

* This command will execute an ’npm install’ to fetch the necessary dependencies, followed by running the application using ’Node.js’.
* Uh oh, we’ve run into a problem! The application is unable to run because the *GuestBook *project requires *MongoDB* to operate properly.

image::missing_mongodb.png[]

---

== Lab 2.2 Adding components to the devfile

* To resolve this, we need to inject an additional MongoDB component into our *devfile*, similar to the following yaml snippet:

```yaml
- name: mongo
    container:
      image: registry.redhat.io/rhscl/mongodb-36-rhel7:1-50
      env:
        - name: MONGODB_USER
          value: user
        - name: MONGODB_PASSWORD
          value: password
        - name: MONGODB_DATABASE
          value: guestbook
        - name: MONGODB_ADMIN_PASSWORD
          value: password
      endpoints:
        - name: mongodb
          exposure: internal
          targetPort: 27017
      memoryLimit: 512Mi
      mountSources: false
      volumeMounts:
        - name: mongo-storage
          path: /var/lib/mongodb/data
  - name: mongo-storage
    volume:
      size: 1G
```

* To simply this step, we've already included the new components in the *devfile* hosted in this branch of the git repository:
** https://github.com/relessawy/devspaces_guestbook/tree/Lab2.2
* Go ahead an delete your current workspace, by clicking on the *Kebab* icon (three vertical dots) next to it and select *Delete Workspace*

image::delete_workspace.png[]

---

* Return to the *Create Workspace* page and provide the new URL in the designated field.
* Click the button *Create & Open* to create the workspace with MongoDB included.

image::workspace_with_mongodb.png[]

---

* The OpenShift Dev Spaces server will process the updated *devfile*.
* As the workspace restarts, switch back to OpenShift to inspect the pods. 
* You’ll now see that the pod hosting your workspace is spinning up three containers instead of two.
* Upon inspecting the pod, you’ll find that a *mongo* container is now part of your deployment.

image::workspace_pod_with_3_containers.png[]

---

* Feel free to explore the updated *devfile* in this *workspace*.
* Let's do another build and run for our application.
* Once again, select and run the command *Run the application command* under the *devfile* section in *Task Manager*.
* As we might expect, tha application connects successfully to the mongo database, and we get a popup asking if we want to Open our Guest Book application in a new tab.
* Click the *Open in New Tab* button.
* Confirm the action to allow VSCode to open the external site by clicking *Open*.

image::open_web_app.png[]

* You should now see the *GuestBook* application running in a separate tab.

image:my_guest_book.png[]

---

== Lab 2.3 Testing and Debugging with OpenShift Dev Spaces

* Now that we have our *GuestBook* application up and running in *OpenShift Dev Spaces*, it’s time to start testing and debugging the application, just as you would in a local development environment. 
* In this lab, we will demonstrate how to leverage the inner loop capabilities of *OpenShift Dev Spaces* to debug and inspect your application within the cloud-native workspace.

---

=== Lab 2.3.1 Inspect messages in MongoDB

* While your workspace can come predefined with extensions, you still have the flexibility to add your favorite extensions, ensuring your development environment suits your workflow.
* Begin by installing the *MongoDB for VS Code* extension to your workspace.

image:install_mongodb_for_vscode_ext.png[]

* Click on the Connect button to create a connection with *Connection String*. 
* Establish a connection to the GuestBook database using the following connection string:

```yaml
mongodb://user:password@localhost:27017/guestbook
```
image:establish_connection_to_mongodb.png[]

---

* Now that you’re connected to the *GuestBook* database, you can inspect all the messages stored within it.
* Go ahead and provide some new messages in the GuestBook application, for example: "Hello World! from Eddie"

image:eddie_says_hello_world.png[]

* After submitting your messages in the application, you’ll be able to trace those messages directly in the *GuestBook* database. This allows you to verify that the application is correctly storing and retrieving data as expected.

image:message_trace.png[]

---

=== Lab 2.3.2 Testing and Debugging

* As part of the inner loop capabilities, you can test and debug your application directly within your *workspace* in *OpenShift Dev Spaces*.
* First, terminate the *Run Application* task to allow us to start the application in *debug mode*.

* image:terminate_task.png[]

* Open the main application file *app.j*s* and add a *breakpoint* at *line 39*. * Copy the variable saveMessages in your clipboard. 

image:add_break_point.png[]

* In the left-hand menu, click on the *Run and Debug* icon.
* From the dropdown at the top, select *Node.js* as the process to attach to.
* Choose the *Run Script: Debug* option to initiate the debug process.

image:start_run_debug_process.png[]

*	Finally, click *Start Debugging* to begin debugging your application in *OpenShift Dev Spaces*.

image:start_debugging.png[]

* You will be prompted to open the debugging port *9229*. Click *Yes* to accept and proceed.

image:open_debugging_port.png[]

* A pop-up will ask if you want to open a new tab for your Node.js application. Click *Open in New Tab*.

* image:open_app_in_debug_mode.png[]

* Another pop-up will ask if you want to allow external website access. Click *Open* to confirm.

image:confirm_open_app.png[]

* To continue the application’s execution, click the Resume button in the debugger.

image:resume_app.png[]

* You can now add a watch to the variable *savedMessages* to monitor its value during execution.

image:add_Watch_savedMessages.png[]

* Let’s add a new record to the *GuestBook*. For example, submit a new message through the GuestBook interface: "Hello World from Ella!".

image:hello_world_from_Ella.png[]

*	In the debugger’s upper menu, select Step Over to advance the execution line by line.

image:step_over.png[]

* You will see all the messages that have been submitted, displayed through the savedMessages variable.

image:watch_messages.png[]

* Once you’re done, you can stop the debugger and terminate the debugging session.

image:stop_debugger.png[]


---

oc login -u opentlc-mgr -p r3dh4t1!

oc apply -f imagestream.yaml

oc apply -f build/buildconfig.yaml 

oc start-build guestbook-dev-environment

mongostat -u admin -p password --authenticationDatabase admin

--plugin registery

pluginRegistry:
      openVSXURL: 'https://open-vsx.org'

--CAmel workspcae


curl -Ls https://sh.jbang.dev | bash -s - app setup

- from:
    uri: "timer:yaml"
    parameters:
      period: "1000"
    steps:
      - setBody:
          simple: "Hello Camel from ${routeId}"
      - log: "${body}"

jbang '-Dcamel.jbang.version=4.2.0' camel@apache/camel run sample-route.camel.yaml --dev --logging-level=info 